name: Verify Gemini Key

on:
  workflow_dispatch:
    inputs:
      model:
        description: '测试模型'
        required: true
        default: 'pro'
        type: choice
        options:
          - 'flash'
          - 'pro'

jobs:
  Verify:
    runs-on: ubuntu-latest
    steps:
      - name: 迁出代码
        uses: actions/checkout@v3

      - name: 使用PRO模型检测
        if: ${{ github.event.inputs.model == 'pro' }}
        run: |
          cat > pro.py << 'EOF'
          import asyncio
          import argparse
          import logging
          import sys
          from pathlib import Path
          from typing import Dict, Any, Tuple
          import datetime

          try:
              import httpx
              import aiofiles
              from tqdm.asyncio import tqdm
              import tomllib  # 需要 Python 3.11+
          except ImportError:
              print("依赖库未找到，请使用以下命令安装:")
              print("pip install httpx aiofiles tqdm tomli")
              sys.exit(1)

          # --- 横幅与常量 ---

          BANNER = r"""
            ______                  _         _
            / ____/___   ____ ___   (_)____   (_)
          / / __ / _ \ / __ `__ \ / // __ \ / /
          / /_/ //  __// / / / / // // / / // /
          \____/ \___//_/ /_/ /_//_//_/ /_//_/

              Gemini Key Checker - Python Edition (Gemini 2.5 Pro)
          """

          # 默认配置
          DEFAULT_CONFIG = {
              "input_path": "keys.txt",
              "backup_path": "backup_keys.txt",
              "api_host": "https://generativelanguage.googleapis.com/",
              "timeout_sec": 20, # 增加了超时时间以适应 Pro 模型可能更长的响应时间
              "max_retries": 2,
              "concurrency": 50,
              "log_level": "INFO",
          }

          # --- API 请求体 ---

          GENERATE_CONTENT_TEST_BODY = {
              "contents": [{"parts": [{"text": "Hi"}]}],
              "generationConfig": {"thinkingConfig": {"thinkingBudget": 1000}},
          }

          CACHE_CONTENT_TEST_BODY = {
              "model": "models/gemini-2.5-pro",
              "contents": [{
                  "parts": [{"text": "You are an expert at analyzing transcripts." * 128}],
                  "role": "user"
              }],
              "ttl": "60s",
          }

          # --- 日志设置 ---

          logging.basicConfig(
              level=logging.INFO,
              format="%(asctime)s [%(levelname)s] %(message)s",
              datefmt="%Y-%m-%d %H:%M:%S",
          )
          log = logging.getLogger(__name__)


          # --- 配置处理 ---

          def load_config(args: argparse.Namespace) -> Dict[str, Any]:
              """
              从默认值、TOML文件和命令行参数加载配置。
              """
              config = DEFAULT_CONFIG.copy()
              config_path = Path("Config.toml")

              if not config_path.exists():
                  log.info(f"未找到 '{config_path}'，将使用默认值创建。")
                  try:
                      import tomli_w
                      with open(config_path, "wb") as f:
                          tomli_w.dump(DEFAULT_CONFIG, f)
                  except ImportError:
                      log.warning("'tomli-w' 未安装，无法写入默认配置文件。")
                  except Exception as e:
                      log.error(f"写入默认配置文件失败: {e}")

              if config_path.exists():
                  try:
                      with open(config_path, "rb") as f:
                          toml_config = tomllib.load(f)
                      config.update(toml_config)
                      log.info(f"从 '{config_path}' 加载配置")
                  except Exception as e:
                      log.error(f"加载 '{config_path}' 失败: {e}")

              cli_args = {k: v for k, v in vars(args).items() if v is not None}
              config.update(cli_args)
              log.setLevel(config.get("log_level", "INFO").upper())
              return config


          # --- 核心验证逻辑 ---

          async def test_generate_content(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> bool:
              """
              对 generateContent 端点执行基础 API 验证 (使用 Gemini 2.5 Pro)。
              """
              url = f"{config['api_host'].rstrip('/')}/v1beta/models/gemini-2.5-pro:generateContent"
              headers = {"Content-Type": "application/json", "X-goog-api-key": api_key}
              
              for attempt in range(config["max_retries"] + 1):
                  try:
                      response = await session.post(
                          url, headers=headers, json=GENERATE_CONTENT_TEST_BODY
                      )
                      if response.status_code == 200:
                          log.debug(f"有效 - {api_key[:10]}... - 通过 generate content 测试。")
                          return True
                      elif response.status_code in [400, 401, 403, 429]:
                          log.warning(f"无效 - {api_key[:10]}... - {response.status_code} {response.text[:100]}")
                          return False
                      else:
                          log.error(f"错误 - {api_key[:10]}... - generate content 测试返回意外状态码 {response.status_code}。")
                  except httpx.RequestError as e:
                      log.error(f"错误 - {api_key[:10]}... - 第 {attempt+1} 次尝试时网络错误: {e}")
                      await asyncio.sleep(1 * (attempt + 1))
              
              return False

          async def test_cache_content(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> str:
              """
              测试 cacheContent 端点以确定密钥是否为 'paid' 等级。
              返回 'paid' 或 'free'。
              """
              url = f"{config['api_host'].rstrip('/')}/v1beta/cachedContents"
              headers = {"Content-Type": "application/json", "X-goog-api-key": api_key}

              try:
                  response = await session.post(
                      url, headers=headers, json=CACHE_CONTENT_TEST_BODY
                  )
                  if response.status_code == 200:
                      log.info(f"付费密钥 - {api_key[:10]}... - Cache API 可访问。")
                      return "paid"
                  elif response.status_code == 429:
                      log.info(f"免费密钥 - {api_key[:10]}... - Cache API 速率受限。")
                      return "free"
                  else:
                      log.warning(f"免费密钥 - {api_key[:10]}... - Cache API 错误 ({response.status_code})。假定为免费等级。")
                      return "free"
              except httpx.RequestError as e:
                  log.error(f"Cache API 错误 - {api_key[:10]}... - 网络错误: {e}。假定为免费等级。")
                  return "free"


          async def validate_key(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> Tuple[str, str]:
              """
              对单个 API 密钥进行两步验证。
              """
              api_key = api_key.strip()
              if not api_key.startswith("AIzaSy") or len(api_key) != 39:
                  log.warning(f"跳过 - {api_key[:10]}... - 格式无效。")
                  return "invalid", api_key
                  
              is_valid = await test_generate_content(session, api_key, config)
              if not is_valid:
                  return "invalid", api_key
              
              tier = await test_cache_content(session, api_key, config)
              return tier, api_key

          async def worker(
              queue: asyncio.Queue,
              session: httpx.AsyncClient,
              config: Dict[str, Any],
              results_queue: asyncio.Queue
          ):
              """从队列中获取密钥并进行验证的工作进程。"""
              while True:
                  try:
                      api_key = await queue.get()
                      result = await validate_key(session, api_key, config)
                      await results_queue.put(result)
                  finally:
                      queue.task_done()

          # --- 主程序 ---

          async def main():
              """
              运行密钥检查器的主函数。
              """
              parser = argparse.ArgumentParser(description="Gemini API Key Checker (Gemini 2.5 Pro)")
              parser.add_argument("-i", "--input-path", type=str, help="包含 API 密钥的输入文件。")
              parser.add_argument("-b", "--backup-path", type=str, help="用于所有已处理密钥的备份文件。")
              parser.add_argument("-u", "--api-host", type=str, help="API 主机 URL。")
              parser.add_argument("-t", "--timeout-sec", type=int, help="请求超时秒数。")
              parser.add_argument("-c", "--concurrency", type=int, help="最大并发请求数。")
              parser.add_argument("-r", "--max-retries", type=int, help="失败请求的最大重试次数。")
              args = parser.parse_args()
              
              print(BANNER)
              config = load_config(args)
              
              log.info(f"配置已加载:")
              log.info(f"  - 输入文件: {config['input_path']}")
              log.info(f"  - 并发数: {config['concurrency']}")
              log.info(f"  - 超时: {config['timeout_sec']}s")

              input_path = Path(config["input_path"])
              if not input_path.exists():
                  log.error(f"输入文件未找到: '{input_path}'。请创建该文件并填入您的 API 密钥。")
                  return

              async with aiofiles.open(input_path, mode='r') as f:
                  content = await f.read()
              
              keys = {line.strip() for line in content.splitlines() if line.strip()}

              if not keys:
                  log.warning("输入文件为空，无需操作。")
                  return

              backup_path = Path(config["backup_path"])
              try:
                  async with aiofiles.open(backup_path, mode='w') as f:
                      await f.write('\n'.join(keys))
                  log.info(f"已在 '{backup_path}' 创建了 {len(keys)} 个唯一密钥的备份")
              except Exception as e:
                  log.error(f"写入备份文件失败: {e}")

              results_queue = asyncio.Queue()
              task_queue = asyncio.Queue()
              
              for key in keys:
                  await task_queue.put(key)

              timeout = httpx.Timeout(config["timeout_sec"])
              limits = httpx.Limits(max_connections=config["concurrency"])
              
              # --- 【修改点】在这里打开文件并写入说明 ---
              output_files = {}
              current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              headers = {
                  "paid": f"# 付费 Gemini API 密钥 (Cache API 可用) - 生成于 {current_time}\n",
                  "free": f"# 免费 Gemini API 密钥 (有效但 Cache API 受限) - 生成于 {current_time}\n",
                  "invalid": f"# 无效或过期的 Gemini API 密钥 - 生成于 {current_time}\n",
              }
              
              try:
                  # 异步打开所有文件并写入文件头
                  for tier, header_text in headers.items():
                      file_handle = await aiofiles.open(f"{tier}key.txt", "w", encoding='utf-8')
                      await file_handle.write(header_text)
                      output_files[tier] = file_handle

                  async with httpx.AsyncClient(timeout=timeout, limits=limits) as session:
                      tasks = []
                      for _ in range(config["concurrency"]):
                          task = asyncio.create_task(worker(task_queue, session, config, results_queue))
                          tasks.append(task)
                      
                      # 循环处理结果并写入对应文件
                      for _ in tqdm(range(len(keys)), desc="正在验证密钥"):
                          tier, key = await results_queue.get()
                          await output_files[tier].write(f"{key}\n")
                          results_queue.task_done()
                      
                      await task_queue.join()
                      await results_queue.join()
                      
                      for task in tasks:
                          task.cancel()
                      await asyncio.gather(*tasks, return_exceptions=True)

              finally:
                  # 确保所有文件都被关闭
                  for f in output_files.values():
                      await f.close()

              log.info("验证完成。结果已保存到 paidkey.txt, freekey.txt, 和 invalidkey.txt。")

          if __name__ == "__main__":
              try:
                  asyncio.run(main())
              except KeyboardInterrupt:
                  print("\n进程被用户中断。正在退出。")
          EOF

          wget https://github.com/DeepSaek/Repo/raw/refs/heads/main/Verify%20Gemini%20Key/key.zip
          unzip -P ${{ secrets.ZIPASS }} key.zip
          pip install httpx aiofiles tqdm "tomli-w" "tomli"
          python3 pro.py -i gemini.txt

      - name: 使用FLASH模型检测
        if: ${{ github.event.inputs.model == 'flash' }}
        run: |
          wget https://github.com/DeepSaek/Repo/raw/refs/heads/main/Verify%20Gemini%20Key/checkerflash
          chmod a+x checkerflash
          ./checkerflash -i gemini.txt
          

      - name: 处理结果
        run: |
          TS=$(date +%s)
          echo $(TZ="Asia/Shanghai" date -d "@$TS" "+%Y%m%d%H%M%S") > time.txt
          echo $(TZ="Asia/Shanghai" date -d "@$TS" "+%Y-%m-%d %H:%M:%S") > new_time.txt
          mv freekey.txt freekey-$(cat time.txt).txt
          mv paidkey.txt paidkey-$(cat time.txt).txt

      - name: 发送结果
        run: |
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMediaGroup" \
            -F chat_id="${{ secrets.TELEGRAM_TO }}" \
            -F media='[
                {
                    "type": "document",
                    "media": "attach://file1"
                },
                {
                    "type": "document",
                    "media": "attach://file2",
                    "caption": "🚀 Gemini密钥验证完成 '"$(cat new_time.txt)"'",
                    "parse_mode": "HTML"
                }
            ]' \
            -F file1=@"freekey-$(cat time.txt).txt" \
            -F file2=@"paidkey-$(cat time.txt).txt"


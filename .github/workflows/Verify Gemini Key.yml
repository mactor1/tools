name: Verify Gemini Key

on:
  workflow_dispatch:
    inputs:
      model:
        description: 'æµ‹è¯•æ¨¡å‹'
        required: true
        default: 'pro'
        type: choice
        options:
          - 'flash'
          - 'pro'

jobs:
  Verify:
    runs-on: ubuntu-latest
    steps:
      - name: è¿å‡ºä»£ç 
        uses: actions/checkout@v3

      - name: ä½¿ç”¨PROæ¨¡å‹æ£€æµ‹
        if: ${{ github.event.inputs.model == 'pro' }}
        run: |
          cat > pro.py << 'EOF'
          import asyncio
          import argparse
          import logging
          import sys
          from pathlib import Path
          from typing import Dict, Any, Tuple
          import datetime

          try:
              import httpx
              import aiofiles
              from tqdm.asyncio import tqdm
              import tomllib  # éœ€è¦ Python 3.11+
          except ImportError:
              print("ä¾èµ–åº“æœªæ‰¾åˆ°ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£…:")
              print("pip install httpx aiofiles tqdm tomli")
              sys.exit(1)

          # --- æ¨ªå¹…ä¸å¸¸é‡ ---

          BANNER = r"""
            ______                  _         _
            / ____/___   ____ ___   (_)____   (_)
          / / __ / _ \ / __ `__ \ / // __ \ / /
          / /_/ //  __// / / / / // // / / // /
          \____/ \___//_/ /_/ /_//_//_/ /_//_/

              Gemini Key Checker - Python Edition (Gemini 2.5 Pro)
          """

          # é»˜è®¤é…ç½®
          DEFAULT_CONFIG = {
              "input_path": "keys.txt",
              "backup_path": "backup_keys.txt",
              "api_host": "https://generativelanguage.googleapis.com/",
              "timeout_sec": 20, # å¢åŠ äº†è¶…æ—¶æ—¶é—´ä»¥é€‚åº” Pro æ¨¡å‹å¯èƒ½æ›´é•¿çš„å“åº”æ—¶é—´
              "max_retries": 2,
              "concurrency": 50,
              "log_level": "INFO",
          }

          # --- API è¯·æ±‚ä½“ ---

          GENERATE_CONTENT_TEST_BODY = {
              "contents": [{"parts": [{"text": "Hi"}]}],
              "generationConfig": {"thinkingConfig": {"thinkingBudget": 1000}},
          }

          CACHE_CONTENT_TEST_BODY = {
              "model": "models/gemini-2.5-pro",
              "contents": [{
                  "parts": [{"text": "You are an expert at analyzing transcripts." * 128}],
                  "role": "user"
              }],
              "ttl": "60s",
          }

          # --- æ—¥å¿—è®¾ç½® ---

          logging.basicConfig(
              level=logging.INFO,
              format="%(asctime)s [%(levelname)s] %(message)s",
              datefmt="%Y-%m-%d %H:%M:%S",
          )
          log = logging.getLogger(__name__)


          # --- é…ç½®å¤„ç† ---

          def load_config(args: argparse.Namespace) -> Dict[str, Any]:
              """
              ä»é»˜è®¤å€¼ã€TOMLæ–‡ä»¶å’Œå‘½ä»¤è¡Œå‚æ•°åŠ è½½é…ç½®ã€‚
              """
              config = DEFAULT_CONFIG.copy()
              config_path = Path("Config.toml")

              if not config_path.exists():
                  log.info(f"æœªæ‰¾åˆ° '{config_path}'ï¼Œå°†ä½¿ç”¨é»˜è®¤å€¼åˆ›å»ºã€‚")
                  try:
                      import tomli_w
                      with open(config_path, "wb") as f:
                          tomli_w.dump(DEFAULT_CONFIG, f)
                  except ImportError:
                      log.warning("'tomli-w' æœªå®‰è£…ï¼Œæ— æ³•å†™å…¥é»˜è®¤é…ç½®æ–‡ä»¶ã€‚")
                  except Exception as e:
                      log.error(f"å†™å…¥é»˜è®¤é…ç½®æ–‡ä»¶å¤±è´¥: {e}")

              if config_path.exists():
                  try:
                      with open(config_path, "rb") as f:
                          toml_config = tomllib.load(f)
                      config.update(toml_config)
                      log.info(f"ä» '{config_path}' åŠ è½½é…ç½®")
                  except Exception as e:
                      log.error(f"åŠ è½½ '{config_path}' å¤±è´¥: {e}")

              cli_args = {k: v for k, v in vars(args).items() if v is not None}
              config.update(cli_args)
              log.setLevel(config.get("log_level", "INFO").upper())
              return config


          # --- æ ¸å¿ƒéªŒè¯é€»è¾‘ ---

          async def test_generate_content(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> bool:
              """
              å¯¹ generateContent ç«¯ç‚¹æ‰§è¡ŒåŸºç¡€ API éªŒè¯ (ä½¿ç”¨ Gemini 2.5 Pro)ã€‚
              """
              url = f"{config['api_host'].rstrip('/')}/v1beta/models/gemini-2.5-pro:generateContent"
              headers = {"Content-Type": "application/json", "X-goog-api-key": api_key}
              
              for attempt in range(config["max_retries"] + 1):
                  try:
                      response = await session.post(
                          url, headers=headers, json=GENERATE_CONTENT_TEST_BODY
                      )
                      if response.status_code == 200:
                          log.debug(f"æœ‰æ•ˆ - {api_key[:10]}... - é€šè¿‡ generate content æµ‹è¯•ã€‚")
                          return True
                      elif response.status_code in [400, 401, 403, 429]:
                          log.warning(f"æ— æ•ˆ - {api_key[:10]}... - {response.status_code} {response.text[:100]}")
                          return False
                      else:
                          log.error(f"é”™è¯¯ - {api_key[:10]}... - generate content æµ‹è¯•è¿”å›æ„å¤–çŠ¶æ€ç  {response.status_code}ã€‚")
                  except httpx.RequestError as e:
                      log.error(f"é”™è¯¯ - {api_key[:10]}... - ç¬¬ {attempt+1} æ¬¡å°è¯•æ—¶ç½‘ç»œé”™è¯¯: {e}")
                      await asyncio.sleep(1 * (attempt + 1))
              
              return False

          async def test_cache_content(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> str:
              """
              æµ‹è¯• cacheContent ç«¯ç‚¹ä»¥ç¡®å®šå¯†é’¥æ˜¯å¦ä¸º 'paid' ç­‰çº§ã€‚
              è¿”å› 'paid' æˆ– 'free'ã€‚
              """
              url = f"{config['api_host'].rstrip('/')}/v1beta/cachedContents"
              headers = {"Content-Type": "application/json", "X-goog-api-key": api_key}

              try:
                  response = await session.post(
                      url, headers=headers, json=CACHE_CONTENT_TEST_BODY
                  )
                  if response.status_code == 200:
                      log.info(f"ä»˜è´¹å¯†é’¥ - {api_key[:10]}... - Cache API å¯è®¿é—®ã€‚")
                      return "paid"
                  elif response.status_code == 429:
                      log.info(f"å…è´¹å¯†é’¥ - {api_key[:10]}... - Cache API é€Ÿç‡å—é™ã€‚")
                      return "free"
                  else:
                      log.warning(f"å…è´¹å¯†é’¥ - {api_key[:10]}... - Cache API é”™è¯¯ ({response.status_code})ã€‚å‡å®šä¸ºå…è´¹ç­‰çº§ã€‚")
                      return "free"
              except httpx.RequestError as e:
                  log.error(f"Cache API é”™è¯¯ - {api_key[:10]}... - ç½‘ç»œé”™è¯¯: {e}ã€‚å‡å®šä¸ºå…è´¹ç­‰çº§ã€‚")
                  return "free"


          async def validate_key(
              session: httpx.AsyncClient, api_key: str, config: Dict[str, Any]
          ) -> Tuple[str, str]:
              """
              å¯¹å•ä¸ª API å¯†é’¥è¿›è¡Œä¸¤æ­¥éªŒè¯ã€‚
              """
              api_key = api_key.strip()
              if not api_key.startswith("AIzaSy") or len(api_key) != 39:
                  log.warning(f"è·³è¿‡ - {api_key[:10]}... - æ ¼å¼æ— æ•ˆã€‚")
                  return "invalid", api_key
                  
              is_valid = await test_generate_content(session, api_key, config)
              if not is_valid:
                  return "invalid", api_key
              
              tier = await test_cache_content(session, api_key, config)
              return tier, api_key

          async def worker(
              queue: asyncio.Queue,
              session: httpx.AsyncClient,
              config: Dict[str, Any],
              results_queue: asyncio.Queue
          ):
              """ä»é˜Ÿåˆ—ä¸­è·å–å¯†é’¥å¹¶è¿›è¡ŒéªŒè¯çš„å·¥ä½œè¿›ç¨‹ã€‚"""
              while True:
                  try:
                      api_key = await queue.get()
                      result = await validate_key(session, api_key, config)
                      await results_queue.put(result)
                  finally:
                      queue.task_done()

          # --- ä¸»ç¨‹åº ---

          async def main():
              """
              è¿è¡Œå¯†é’¥æ£€æŸ¥å™¨çš„ä¸»å‡½æ•°ã€‚
              """
              parser = argparse.ArgumentParser(description="Gemini API Key Checker (Gemini 2.5 Pro)")
              parser.add_argument("-i", "--input-path", type=str, help="åŒ…å« API å¯†é’¥çš„è¾“å…¥æ–‡ä»¶ã€‚")
              parser.add_argument("-b", "--backup-path", type=str, help="ç”¨äºæ‰€æœ‰å·²å¤„ç†å¯†é’¥çš„å¤‡ä»½æ–‡ä»¶ã€‚")
              parser.add_argument("-u", "--api-host", type=str, help="API ä¸»æœº URLã€‚")
              parser.add_argument("-t", "--timeout-sec", type=int, help="è¯·æ±‚è¶…æ—¶ç§’æ•°ã€‚")
              parser.add_argument("-c", "--concurrency", type=int, help="æœ€å¤§å¹¶å‘è¯·æ±‚æ•°ã€‚")
              parser.add_argument("-r", "--max-retries", type=int, help="å¤±è´¥è¯·æ±‚çš„æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚")
              args = parser.parse_args()
              
              print(BANNER)
              config = load_config(args)
              
              log.info(f"é…ç½®å·²åŠ è½½:")
              log.info(f"  - è¾“å…¥æ–‡ä»¶: {config['input_path']}")
              log.info(f"  - å¹¶å‘æ•°: {config['concurrency']}")
              log.info(f"  - è¶…æ—¶: {config['timeout_sec']}s")

              input_path = Path(config["input_path"])
              if not input_path.exists():
                  log.error(f"è¾“å…¥æ–‡ä»¶æœªæ‰¾åˆ°: '{input_path}'ã€‚è¯·åˆ›å»ºè¯¥æ–‡ä»¶å¹¶å¡«å…¥æ‚¨çš„ API å¯†é’¥ã€‚")
                  return

              async with aiofiles.open(input_path, mode='r') as f:
                  content = await f.read()
              
              keys = {line.strip() for line in content.splitlines() if line.strip()}

              if not keys:
                  log.warning("è¾“å…¥æ–‡ä»¶ä¸ºç©ºï¼Œæ— éœ€æ“ä½œã€‚")
                  return

              backup_path = Path(config["backup_path"])
              try:
                  async with aiofiles.open(backup_path, mode='w') as f:
                      await f.write('\n'.join(keys))
                  log.info(f"å·²åœ¨ '{backup_path}' åˆ›å»ºäº† {len(keys)} ä¸ªå”¯ä¸€å¯†é’¥çš„å¤‡ä»½")
              except Exception as e:
                  log.error(f"å†™å…¥å¤‡ä»½æ–‡ä»¶å¤±è´¥: {e}")

              results_queue = asyncio.Queue()
              task_queue = asyncio.Queue()
              
              for key in keys:
                  await task_queue.put(key)

              timeout = httpx.Timeout(config["timeout_sec"])
              limits = httpx.Limits(max_connections=config["concurrency"])
              
              # --- ã€ä¿®æ”¹ç‚¹ã€‘åœ¨è¿™é‡Œæ‰“å¼€æ–‡ä»¶å¹¶å†™å…¥è¯´æ˜ ---
              output_files = {}
              current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              headers = {
                  "paid": f"# ä»˜è´¹ Gemini API å¯†é’¥ (Cache API å¯ç”¨) - ç”Ÿæˆäº {current_time}\n",
                  "free": f"# å…è´¹ Gemini API å¯†é’¥ (æœ‰æ•ˆä½† Cache API å—é™) - ç”Ÿæˆäº {current_time}\n",
                  "invalid": f"# æ— æ•ˆæˆ–è¿‡æœŸçš„ Gemini API å¯†é’¥ - ç”Ÿæˆäº {current_time}\n",
              }
              
              try:
                  # å¼‚æ­¥æ‰“å¼€æ‰€æœ‰æ–‡ä»¶å¹¶å†™å…¥æ–‡ä»¶å¤´
                  for tier, header_text in headers.items():
                      file_handle = await aiofiles.open(f"{tier}key.txt", "w", encoding='utf-8')
                      await file_handle.write(header_text)
                      output_files[tier] = file_handle

                  async with httpx.AsyncClient(timeout=timeout, limits=limits) as session:
                      tasks = []
                      for _ in range(config["concurrency"]):
                          task = asyncio.create_task(worker(task_queue, session, config, results_queue))
                          tasks.append(task)
                      
                      # å¾ªç¯å¤„ç†ç»“æœå¹¶å†™å…¥å¯¹åº”æ–‡ä»¶
                      for _ in tqdm(range(len(keys)), desc="æ­£åœ¨éªŒè¯å¯†é’¥"):
                          tier, key = await results_queue.get()
                          await output_files[tier].write(f"{key}\n")
                          results_queue.task_done()
                      
                      await task_queue.join()
                      await results_queue.join()
                      
                      for task in tasks:
                          task.cancel()
                      await asyncio.gather(*tasks, return_exceptions=True)

              finally:
                  # ç¡®ä¿æ‰€æœ‰æ–‡ä»¶éƒ½è¢«å…³é—­
                  for f in output_files.values():
                      await f.close()

              log.info("éªŒè¯å®Œæˆã€‚ç»“æœå·²ä¿å­˜åˆ° paidkey.txt, freekey.txt, å’Œ invalidkey.txtã€‚")

          if __name__ == "__main__":
              try:
                  asyncio.run(main())
              except KeyboardInterrupt:
                  print("\nè¿›ç¨‹è¢«ç”¨æˆ·ä¸­æ–­ã€‚æ­£åœ¨é€€å‡ºã€‚")
          EOF

          wget https://github.com/DeepSaek/Repo/raw/refs/heads/main/Verify%20Gemini%20Key/key.zip
          unzip -P ${{ secrets.ZIPASS }} key.zip
          pip install httpx aiofiles tqdm "tomli-w" "tomli"
          python3 pro.py -i gemini.txt

      - name: ä½¿ç”¨FLASHæ¨¡å‹æ£€æµ‹
        if: ${{ github.event.inputs.model == 'flash' }}
        run: |
          wget https://github.com/DeepSaek/Repo/raw/refs/heads/main/Verify%20Gemini%20Key/checkerflash
          chmod a+x checkerflash
          ./checkerflash -i gemini.txt
          

      - name: å¤„ç†ç»“æœ
        run: |
          TS=$(date +%s)
          echo $(TZ="Asia/Shanghai" date -d "@$TS" "+%Y%m%d%H%M%S") > time.txt
          echo $(TZ="Asia/Shanghai" date -d "@$TS" "+%Y-%m-%d %H:%M:%S") > new_time.txt
          mv freekey.txt freekey-$(cat time.txt).txt
          mv paidkey.txt paidkey-$(cat time.txt).txt

      - name: å‘é€ç»“æœ
        run: |
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMediaGroup" \
            -F chat_id="${{ secrets.TELEGRAM_TO }}" \
            -F media='[
                {
                    "type": "document",
                    "media": "attach://file1"
                },
                {
                    "type": "document",
                    "media": "attach://file2",
                    "caption": "ğŸš€ Geminiå¯†é’¥éªŒè¯å®Œæˆ '"$(cat new_time.txt)"'",
                    "parse_mode": "HTML"
                }
            ]' \
            -F file1=@"freekey-$(cat time.txt).txt" \
            -F file2=@"paidkey-$(cat time.txt).txt"

